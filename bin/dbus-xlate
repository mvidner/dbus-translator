#!/usr/bin/env ruby
# frozen_string_literal: true

require "shellwords"

class Message
  # @return [:signal,:method_call]
  attr_accessor :type

  # @return [String]
  attr_accessor :path, :interface, :member, :destination, :signature

  # @return [Array] of what
  attr_accessor :body
end

class Command
  # @return [String,:system,:session]
  attr_accessor :address
  # @return [Message]
  attr_accessor :message
  # @return [Boolean]
  attr_accessor :quiet

  def initialize(command = nil)
    return if command.nil?

    @address = command.address
    @message = command.message
    @quiet = command.quiet
  end
end

class DBusSend < Command
  # @param argv [Array<String>] CLI args where the first one is "dbus-send"
  # @return [DBusSend]
  def self.parse_argv(argv)
    # $ dbus-send --print-reply --dest=org.freedesktop.DBus /org/freedesktop/DBus org.freedesktop.DBus.GetId
    argv = argv.dup
    cmd_s = argv.shift
    raise LogicError unless cmd_s == "dbus-send"

    command = new
    command.address = :session

    command.message = message = Message.new
    message.type = :signal
    # what if --dest is omitted?
    message.destination = nil

    while argv.first.start_with? "--"
      case argv.first
      when /--dest=(.*)/
        message.destination = Regexp.last_match(1)
      when "--print-reply", "--print-reply=literal"
        command.quiet = false
        message.type = :method_call
      when "--system"
        command.address = :system
      when "--session"
        command.address = :session
      else
        warn "Unrecognized option #{argv.first.inspect}"
      end
      argv.shift
    end

    # Parse positional arguments
    message.path = argv.shift
    interface_method = argv.shift
    message.interface, _dot, message.member = interface_method.rpartition "."

    warn "Parameter passing not yet implemented" unless argv.empty?

    command
  end

  def to_s
    addr_s = case address
             when :system
               "--system"
             when :session
               "--session"
             else
               "--address=#{address}"
             end

    argv = [
      "dbus-send",
      addr_s,
      message.type == :method_call ? "--print-reply" : nil,
      "--dest=#{message.destination}",
      message.path,
      "#{message.interface}.#{message.member}"
    ].compact

    argv.shelljoin
  end
end

class Busctl < Command
  def self.program
    "busctl"
  end

  # @param argv [Array<String>] CLI args where the first one is "busctl"
  # @return [Busctl]
  def self.parse_argv(argv)
    # busctl --user call org.freedesktop.DBus /org/freedesktop/DBus org.freedesktop.DBus GetId
    # busctl get-property org.freedesktop.DBus /org/freedesktop/DBus org.freedesktop.DBus Interfaces
    argv = argv.dup
    cmd_s = argv.shift
    raise LogicError unless cmd_s == program

    command = new
    command.address = :system
    command.quiet = false
    command.message = message = Message.new

    while argv.first.start_with? "-"
      case argv.first
      when /--destination=(.*)/
        message.destination = Regexp.last_match(1)
      when "--quiet", "-q"
        command.quiet = true
      when "--system"
        command.address = :system
      when "--user"
        command.address = :session
      else
        warn "Unrecognized option #{argv.first.inspect}"
      end
      argv.shift
    end

    # Parse positional arguments

    case argv.first
    when "call"
      message.type = :method_call
      argv.shift

      message.destination = argv.shift
      message.path = argv.shift
      message.interface = argv.shift
      message.member = argv.shift
    when "emit"
      message.type = :signal
      argv.shift

      message.path = argv.shift
      message.interface = argv.shift
      message.member = argv.shift
    when "get-property"
      message.type = :method_call
      argv.shift

      message.path = argv.shift
      p_interface = argv.shift
      p_member = argv.shift
      message.interface = "org.freedesktop.DBus.Properties"
      message.member = "Get"
      # TODO: typed data
      message.signature = "ss"
      message.body = [p_interface, p_member]
    else
      warn "Unrecognized verb #{argv.first.inspect}"
    end

    warn "Parameter passing not yet implemented" unless argv.empty?

    command
  end

  def to_s
    addr_s = case address
             when :system
               "--system"
             when :session
               "--user"
             else
               "--address=#{address}"
             end

    argv = [
      "busctl",
      quiet ? "--quiet" : nil,
      addr_s,
      message.type == :method_call ? "call" : "emit",
      message.type == :method_call ? message.destination : nil,
      message.path,
      message.interface,
      message.member
    ].compact

    argv.shelljoin
  end
end

class GDBus < Command
  def to_s
    addr_s = case address
             when :system
               "--system"
             when :session
               "--session"
             else
               "--address=#{address}"
             end

    argv = [
      "gdbus",
      message.type == :method_call ? "call" : "emit",
      addr_s,
      "--dest", message.destination,
      "--object-path", message.path,
      message.type == :method_call ? "--method" : "--signal",
      "#{message.interface}.#{message.member}"
    ].compact

    argv.shelljoin
  end
end

command = case ARGV.first
          when "dbus-send"
            DBusSend.parse_argv(ARGV)
          when "busctl"
            Busctl.parse_argv(ARGV)
          when "gdbus"
            GDBus.parse_argv(ARGV)
          else
            warn "Unrecognized tool #{command.inspect}"
            exit 1
          end

puts DBusSend.new(command)
puts Busctl.new(command)
puts GDBus.new(command)
